{"ast":null,"code":"let last_request_timer = null;\n/**\n * @param {String} url\n * Делает запрос по заданному к API с помощью fetch. Также обновляет статус \"онлайн\" каждый 30 секунд, если запросов в течении этого времени не было\n * @param {String} [method='get']\n * @param {Object} params\n * @param {Boolean} [token=true] is auth needed\n * @param {Boolean} is_url_full\n * @param {Object} options:\n * - parse_type - json | text\n * - token\n * - abortController\n * @return {Promise}\n */\n\nexport function request(url, method = 'GET', params, token = true, is_url_full, options = {}) {\n  if (token === false) {} // if (window.navigator.onLine === false) {\n  // \tpushMessage('Нет соединения с сетью');\n  // \treturn Promise.reject({error_text: 'Нет соединения с сетью'});\n  // }\n  // saveLog(method+' request to '+url+' ; is_url_full = '+is_url_full);\n  // saveLog(\"params = \");\n\n\n  last_request_timer && clearTimeout(last_request_timer);\n  last_request_timer = setTimeout(() => {\n    request('/setOnline', 'POST');\n  }, 5000);\n  if (options.parse_type === undefined) options.parse_type = 'json'; // saveLog('parse_type = '+options.parse_type);\n\n  let body;\n\n  if (params) {\n    switch (method) {\n      case 'GET':\n      case 'get':\n        url = url; // saveLog(url);\n\n        break;\n\n      case 'POST':\n      case 'post':\n        body = JSON.stringify(params); // saveLog(body);\n\n        break;\n    }\n  }\n\n  let headers = method === 'POST' || method === 'post' ? {\n    'X-Requested-With': 'XMLHttpRequest',\n    'content-type': 'application/json',\n    'Accept': 'application/json, application/xml, text/plain, text/html, *.*'\n  } : {}; // headers['Authorization'] = 'Basic ' + base64.encode(\"iarny:\"));\n\n  let APP_SERVER = window.APP_SERVER;\n  return fetch(url, {\n    signal: options.abortController ? options.abortController.signal : undefined,\n    method: method,\n    headers: headers,\n    credentials: 'same-origin',\n    body: body\n  }).then(response => {\n    // saveLog(\"response = \");\n    // saveLog(response.ok);\n    if (response.ok) {\n      let parser = {\n        json: () => response.json(),\n        text: () => response.text()\n      }[options.parse_type];\n      return parser();\n    }\n\n    return response.json();\n  }).catch(error => {\n    // saveLog(\"error in url \"+`${is_url_full ? '' : APP_SERVER}${url}${debug_profile}`)\n    // saveLog(error);\n    // throw new Error(\"request.js\");\n    return Promise.reject(error);\n  });\n}","map":{"version":3,"sources":["/home/aziza/reactapp/src/actions/request.js"],"names":["last_request_timer","request","url","method","params","token","is_url_full","options","clearTimeout","setTimeout","parse_type","undefined","body","JSON","stringify","headers","APP_SERVER","window","fetch","signal","abortController","credentials","then","response","ok","parser","json","text","catch","error","Promise","reject"],"mappings":"AAAA,IAAIA,kBAAkB,GAAG,IAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,OAAT,CAAiBC,GAAjB,EAAsBC,MAAM,GAAG,KAA/B,EAAsCC,MAAtC,EAA8CC,KAAK,GAAG,IAAtD,EAA4DC,WAA5D,EAAyEC,OAAO,GAAG,EAAnF,EAAuF;AAC7F,MAAIF,KAAK,KAAK,KAAd,EAAqB,CACpB,CAF4F,CAG7F;AACA;AACA;AACA;AACA;AACA;;;AACAL,EAAAA,kBAAkB,IAAIQ,YAAY,CAACR,kBAAD,CAAlC;AACAA,EAAAA,kBAAkB,GAAGS,UAAU,CAAC,MAAM;AACrCR,IAAAA,OAAO,CAAC,YAAD,EAAe,MAAf,CAAP;AACA,GAF8B,EAE5B,IAF4B,CAA/B;AAGA,MAAIM,OAAO,CAACG,UAAR,KAAuBC,SAA3B,EAAsCJ,OAAO,CAACG,UAAR,GAAqB,MAArB,CAbuD,CAc7F;;AACA,MAAIE,IAAJ;;AACA,MAAKR,MAAL,EAAc;AACb,YAAQD,MAAR;AACC,WAAK,KAAL;AACA,WAAK,KAAL;AACED,QAAAA,GAAG,GAAGA,GAAN,CADF,CAEE;;AACA;;AACF,WAAK,MAAL;AACA,WAAK,MAAL;AACEU,QAAAA,IAAI,GAAGC,IAAI,CAACC,SAAL,CAAeV,MAAf,CAAP,CADF,CAEE;;AACA;AAVH;AAYA;;AACD,MAAIW,OAAO,GAAGZ,MAAM,KAAK,MAAX,IAAqBA,MAAM,KAAK,MAAhC,GAAyC;AACtD,wBAAoB,gBADkC;AAEtD,oBAAgB,kBAFsC;AAGtD,cAAU;AAH4C,GAAzC,GAIV,EAJJ,CA9B6F,CAmC7F;;AACA,MAAIa,UAAU,GAAGC,MAAM,CAACD,UAAxB;AAEA,SAAOE,KAAK,CAAChB,GAAD,EAAM;AACjBiB,IAAAA,MAAM,EAAEZ,OAAO,CAACa,eAAR,GAA0Bb,OAAO,CAACa,eAAR,CAAwBD,MAAlD,GAA2DR,SADlD;AAEjBR,IAAAA,MAAM,EAAEA,MAFS;AAGjBY,IAAAA,OAAO,EAAEA,OAHQ;AAIjBM,IAAAA,WAAW,EAAE,aAJI;AAKjBT,IAAAA,IAAI,EAAEA;AALW,GAAN,CAAL,CAMJU,IANI,CAMCC,QAAQ,IAAI;AACnB;AACA;AACA,QAAIA,QAAQ,CAACC,EAAb,EAAiB;AAChB,UAAIC,MAAM,GAAG;AACZC,QAAAA,IAAI,EAAE,MAAMH,QAAQ,CAACG,IAAT,EADA;AAEZC,QAAAA,IAAI,EAAE,MAAMJ,QAAQ,CAACI,IAAT;AAFA,QAGXpB,OAAO,CAACG,UAHG,CAAb;AAIA,aAAOe,MAAM,EAAb;AACA;;AACD,WAAOF,QAAQ,CAACG,IAAT,EAAP;AACA,GAjBM,EAiBJE,KAjBI,CAiBEC,KAAK,IAAI;AACjB;AACA;AACA;AACA,WAAOC,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACA,GAtBM,CAAP;AAuBA","sourcesContent":["let last_request_timer = null;\n/**\n * @param {String} url\n * Делает запрос по заданному к API с помощью fetch. Также обновляет статус \"онлайн\" каждый 30 секунд, если запросов в течении этого времени не было\n * @param {String} [method='get']\n * @param {Object} params\n * @param {Boolean} [token=true] is auth needed\n * @param {Boolean} is_url_full\n * @param {Object} options:\n * - parse_type - json | text\n * - token\n * - abortController\n * @return {Promise}\n */\nexport function request(url, method = 'GET', params, token = true, is_url_full, options = {}) {\n\tif (token === false) {\n\t}\n\t// if (window.navigator.onLine === false) {\n\t// \tpushMessage('Нет соединения с сетью');\n\t// \treturn Promise.reject({error_text: 'Нет соединения с сетью'});\n\t// }\n\t// saveLog(method+' request to '+url+' ; is_url_full = '+is_url_full);\n\t// saveLog(\"params = \");\n\tlast_request_timer && clearTimeout(last_request_timer);\n\tlast_request_timer = setTimeout(() => {\n\t\trequest('/setOnline', 'POST');\n\t}, 5000);\n\tif (options.parse_type === undefined) options.parse_type = 'json';\n\t// saveLog('parse_type = '+options.parse_type);\n\tlet body;\n\tif ( params ) {\n\t\tswitch (method) {\n\t\t\tcase 'GET':\n\t\t\tcase 'get':\n\t\t\t  url = url;\n\t\t\t  // saveLog(url);\n\t\t\t  break;\n\t\t\tcase 'POST':\n\t\t\tcase 'post':\n\t\t\t  body = JSON.stringify(params);\n\t\t\t  // saveLog(body);\n\t\t\t  break;\n\t\t}\n\t}\n\tlet headers = method === 'POST' || method === 'post' ? {\n\t\t'X-Requested-With': 'XMLHttpRequest',\n\t\t'content-type': 'application/json',\n\t\t'Accept': 'application/json, application/xml, text/plain, text/html, *.*',\n\t} : {};\n\t// headers['Authorization'] = 'Basic ' + base64.encode(\"iarny:\"));\n\tlet APP_SERVER = window.APP_SERVER;\n\n\treturn fetch(url, {\n\t\tsignal: options.abortController ? options.abortController.signal : undefined,\n\t\tmethod: method,\n\t\theaders: headers,\n\t\tcredentials: 'same-origin' ,\n\t\tbody: body,\n\t}).then(response => {\n\t\t// saveLog(\"response = \");\n\t\t// saveLog(response.ok);\n\t\tif (response.ok) {\n\t\t\tlet parser = {\n\t\t\t\tjson: () => response.json(),\n\t\t\t\ttext: () => response.text(),\n\t\t\t}[options.parse_type];\n\t\t\treturn parser();\n\t\t}\n\t\treturn response.json();\n\t}).catch(error => {\n\t\t// saveLog(\"error in url \"+`${is_url_full ? '' : APP_SERVER}${url}${debug_profile}`)\n\t\t// saveLog(error);\n\t\t// throw new Error(\"request.js\");\n\t\treturn Promise.reject(error);\n\t});\n}"]},"metadata":{},"sourceType":"module"}