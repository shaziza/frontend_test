{"ast":null,"code":"/**\n * @param {String} url\n * Делает запрос по заданному к API с помощью fetch. Также обновляет статус \"онлайн\" каждый 30 секунд, если запросов в течении этого времени не было\n * @param {String} [method='get']\n * @param {Object} params\n * @param {Boolean} [token=true] is auth needed\n * @param {Boolean} is_url_full\n * @param {Object} options:\n * - parse_type - json | text\n * - token\n * - abortController\n * @return {Promise}\n */\nexport function request(url, method = 'GET', params, token = true, is_url_full, options = {}) {\n  if (token === false) {}\n\n  if (options.parse_type === undefined) options.parse_type = 'json';\n  let body;\n\n  if (params) {\n    switch (method) {\n      case 'GET':\n      case 'get':\n        url = url; // saveLog(url);\n\n        break;\n\n      case 'POST':\n      case 'post':\n        body = JSON.stringify(params); // saveLog(body);\n\n        break;\n    }\n  }\n\n  let headers = method === 'POST' || method === 'post' ? {\n    'X-Requested-With': 'XMLHttpRequest',\n    'content-type': 'application/json',\n    'Accept': 'application/json, application/xml, text/plain, text/html, *.*'\n  } : {}; // headers['Authorization'] = 'Basic ' + base64.encode(\"iarny:\"));\n\n  let APP_SERVER = window.APP_SERVER;\n  return fetch(url, {\n    signal: options.abortController ? options.abortController.signal : undefined,\n    method: method,\n    headers: headers,\n    credentials: 'same-origin',\n    body: body\n  }).then(response => {\n    // saveLog(\"response = \");\n    // saveLog(response.ok);\n    if (response.ok) {\n      let parser = {\n        json: () => response.json(),\n        text: () => response.text()\n      }[options.parse_type];\n      return parser();\n    }\n\n    return response.json();\n  }).catch(error => {\n    // saveLog(\"error in url \"+`${is_url_full ? '' : APP_SERVER}${url}${debug_profile}`)\n    // saveLog(error);\n    // throw new Error(\"request.js\");\n    return Promise.reject(error);\n  });\n}","map":{"version":3,"sources":["/home/aziza/reactapp/src/actions/request.js"],"names":["request","url","method","params","token","is_url_full","options","parse_type","undefined","body","JSON","stringify","headers","APP_SERVER","window","fetch","signal","abortController","credentials","then","response","ok","parser","json","text","catch","error","Promise","reject"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,OAAT,CAAiBC,GAAjB,EAAsBC,MAAM,GAAG,KAA/B,EAAsCC,MAAtC,EAA8CC,KAAK,GAAG,IAAtD,EAA4DC,WAA5D,EAAyEC,OAAO,GAAG,EAAnF,EAAuF;AAC7F,MAAIF,KAAK,KAAK,KAAd,EAAqB,CACpB;;AACD,MAAIE,OAAO,CAACC,UAAR,KAAuBC,SAA3B,EAAsCF,OAAO,CAACC,UAAR,GAAqB,MAArB;AACtC,MAAIE,IAAJ;;AACA,MAAKN,MAAL,EAAc;AACb,YAAQD,MAAR;AACC,WAAK,KAAL;AACA,WAAK,KAAL;AACED,QAAAA,GAAG,GAAGA,GAAN,CADF,CAEE;;AACA;;AACF,WAAK,MAAL;AACA,WAAK,MAAL;AACEQ,QAAAA,IAAI,GAAGC,IAAI,CAACC,SAAL,CAAeR,MAAf,CAAP,CADF,CAEE;;AACA;AAVH;AAYA;;AACD,MAAIS,OAAO,GAAGV,MAAM,KAAK,MAAX,IAAqBA,MAAM,KAAK,MAAhC,GAAyC;AACtD,wBAAoB,gBADkC;AAEtD,oBAAgB,kBAFsC;AAGtD,cAAU;AAH4C,GAAzC,GAIV,EAJJ,CAnB6F,CAwB7F;;AACA,MAAIW,UAAU,GAAGC,MAAM,CAACD,UAAxB;AAEA,SAAOE,KAAK,CAACd,GAAD,EAAM;AACjBe,IAAAA,MAAM,EAAEV,OAAO,CAACW,eAAR,GAA0BX,OAAO,CAACW,eAAR,CAAwBD,MAAlD,GAA2DR,SADlD;AAEjBN,IAAAA,MAAM,EAAEA,MAFS;AAGjBU,IAAAA,OAAO,EAAEA,OAHQ;AAIjBM,IAAAA,WAAW,EAAE,aAJI;AAKjBT,IAAAA,IAAI,EAAEA;AALW,GAAN,CAAL,CAMJU,IANI,CAMCC,QAAQ,IAAI;AACnB;AACA;AACA,QAAIA,QAAQ,CAACC,EAAb,EAAiB;AAChB,UAAIC,MAAM,GAAG;AACZC,QAAAA,IAAI,EAAE,MAAMH,QAAQ,CAACG,IAAT,EADA;AAEZC,QAAAA,IAAI,EAAE,MAAMJ,QAAQ,CAACI,IAAT;AAFA,QAGXlB,OAAO,CAACC,UAHG,CAAb;AAIA,aAAOe,MAAM,EAAb;AACA;;AACD,WAAOF,QAAQ,CAACG,IAAT,EAAP;AACA,GAjBM,EAiBJE,KAjBI,CAiBEC,KAAK,IAAI;AACjB;AACA;AACA;AACA,WAAOC,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACA,GAtBM,CAAP;AAuBA","sourcesContent":["\n/**\n * @param {String} url\n * Делает запрос по заданному к API с помощью fetch. Также обновляет статус \"онлайн\" каждый 30 секунд, если запросов в течении этого времени не было\n * @param {String} [method='get']\n * @param {Object} params\n * @param {Boolean} [token=true] is auth needed\n * @param {Boolean} is_url_full\n * @param {Object} options:\n * - parse_type - json | text\n * - token\n * - abortController\n * @return {Promise}\n */\nexport function request(url, method = 'GET', params, token = true, is_url_full, options = {}) {\n\tif (token === false) {\n\t}\n\tif (options.parse_type === undefined) options.parse_type = 'json';\n\tlet body;\n\tif ( params ) {\n\t\tswitch (method) {\n\t\t\tcase 'GET':\n\t\t\tcase 'get':\n\t\t\t  url = url;\n\t\t\t  // saveLog(url);\n\t\t\t  break;\n\t\t\tcase 'POST':\n\t\t\tcase 'post':\n\t\t\t  body = JSON.stringify(params);\n\t\t\t  // saveLog(body);\n\t\t\t  break;\n\t\t}\n\t}\n\tlet headers = method === 'POST' || method === 'post' ? {\n\t\t'X-Requested-With': 'XMLHttpRequest',\n\t\t'content-type': 'application/json',\n\t\t'Accept': 'application/json, application/xml, text/plain, text/html, *.*',\n\t} : {};\n\t// headers['Authorization'] = 'Basic ' + base64.encode(\"iarny:\"));\n\tlet APP_SERVER = window.APP_SERVER;\n\n\treturn fetch(url, {\n\t\tsignal: options.abortController ? options.abortController.signal : undefined,\n\t\tmethod: method,\n\t\theaders: headers,\n\t\tcredentials: 'same-origin' ,\n\t\tbody: body,\n\t}).then(response => {\n\t\t// saveLog(\"response = \");\n\t\t// saveLog(response.ok);\n\t\tif (response.ok) {\n\t\t\tlet parser = {\n\t\t\t\tjson: () => response.json(),\n\t\t\t\ttext: () => response.text(),\n\t\t\t}[options.parse_type];\n\t\t\treturn parser();\n\t\t}\n\t\treturn response.json();\n\t}).catch(error => {\n\t\t// saveLog(\"error in url \"+`${is_url_full ? '' : APP_SERVER}${url}${debug_profile}`)\n\t\t// saveLog(error);\n\t\t// throw new Error(\"request.js\");\n\t\treturn Promise.reject(error);\n\t});\n}"]},"metadata":{},"sourceType":"module"}